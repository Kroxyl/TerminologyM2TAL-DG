Feedback-Based Tree Search for Reinforcement Learning
Daniel R. Jiang 1 Emmanuel Ekwedike 2 3 Han Liu 2 4
Abstract
Inspired by recent successes of Monte-Carlo tree
search (MCTS) in a number of artificial intelligence (AI) application domains, we propose a
model-based reinforcement learning (RL) technique that iteratively applies MCTS on batches
of small, finite-horizon versions of the original
infinite-horizon Markov decision process. The
terminal condition of the finite-horizon problems,
or the leaf-node evaluator of the decision tree generated by MCTS, is specified using a combination
of an estimated value function and an estimated
policy function. The recommendations generated
by the MCTS procedure are then provided as feedback in order to refine, through classification and
regression, the leaf-node evaluator for the next
iteration. We provide the first sample complexity
bounds for a tree search-based RL algorithm. In
addition, we show that a deep neural network implementation of the technique can create a competitive AI agent for the popular multi-player online
battle arena (MOBA) game King of Glory.
1. Introduction
Monte-Carlo tree search (MCTS), introduced in Coulom
(2006) and surveyed in detail by Browne et al. (2012), has received attention in recent years for its successes in gameplay
artificial intelligence (AI), culminating in the Go-playing
AI AlphaGo (Silver et al., 2016). MCTS seeks to iteratively
build the decision tree associated with a given Markov decision process (MDP) so that attention is focused on ‚Äúimportant‚Äù areas of the state space, assuming a given initial state
(or root node of the decision tree). The intuition behind
MCTS is that if rough estimates of state or action values are
given, then it is only necessary to expand the decision tree
in the direction of states and actions with high estimated
value. To accomplish this, MCTS utilizes the guidance of
1University of Pittsburgh 2Tencent AI Lab 3
Princeton University 4Northwestern University. Correspondence to: Daniel R. Jiang
<drjiang@pitt.edu>.
Proceedings of the 35 th International Conference on Machine
Learning, Stockholm, Sweden, PMLR 80, 2018. Copyright 2018
by the author(s).
leaf-node evaluators (either a policy function (Chaslot et al.,
2006) rollout, a value function evaluation (Campbell et al.,
2002; Enzenberger, 2004), or a mixture of both (Silver et al.,
2016)) to produce estimates of downstream values once the
tree has reached a certain depth (Browne et al., 2012). The
information from the leaf-nodes are then backpropagated
up the tree. The performance of MCTS depends heavily
on the quality of the policy/value approximations (Gelly &
Silver, 2007), and at the same time, the successes of MCTS
in Go show that MCTS improves upon a given policy when
the policy is used for leaf evaluation, and in fact, it can
be viewed as a policy improvement operator (Silver et al.,
2017). In this paper, we study a new feedback-based framework, wherein MCTS updates its own leaf-node evaluators
using observations generated at the root node.
MCTS is typically viewed as an online planner, where a
decision tree is built starting from the current state as the
root node (Chaslot et al., 2006; 2008; Hingston & Masek,
2007; MaÀÜƒ±trepierre et al., 2008; Cazenave, 2009; Mehat & ¬¥
Cazenave, 2010; Gelly & Silver, 2011; Gelly et al., 2012;
Silver et al., 2016). The standard goal of MCTS is to recommend an action for the root node only. After the action is
taken, the system moves forward and a new tree is created
from the next state (statistics from the old tree may be partially saved or completely discarded). MCTS is thus a ‚Äúlocal‚Äù
procedure (in that it only returns an action for a given state)
and is inherently different from value function approximation or policy function approximation approaches where a
‚Äúglobal‚Äù policy (one that contains policy information about
all states) is built. In real-time decision-making applications,
it is more difficult to build an adequate ‚Äúon-the-fly‚Äù local
approximation than it is to use pre-trained global policy
in the short amount of time available for decision-making.
For games like Chess or Go, online planning using MCTS
may be appropriate, but in games where fast decisions are
necessary (e.g., Atari or MOBA video games), tree search
methods are too slow (Guo et al., 2014). The proposed
algorithm is intended to be used in an off-policy fashion during the reinforcement learning (RL) training phase. Once
the training is complete, the policies associated with leafnode evaluation can be implemented to make fast, real-time
decisions without any further need for tree search.
Main Contributions. These characteristics of MCTS motivate our proposed method, which attempts to leverage the
arXiv:1805.05935v1 [cs.AI] 15 May 2018
Feedback-Based Tree Search for Reinforcement Learning
local properties of MCTS into a training procedure to iteratively build global policy across all states. The idea is to
apply MCTS on batches of small, finite-horizon versions
of the original infinite-horizon Markov decision process
(MDP). A rough summary is as follows: (1) initialize an
arbitrary value function and a policy function; (2) start (possibly in parallel) a batch of MCTS instances, limited in
search-depth, initialized from a set of sampled states, while
incorporating a combination of the value and policy function
as leaf-node evaluators; (3) update both the value and policy
functions using the latest MCTS root node observations;
(4) Repeat starting from step (2). This method exploits
the idea that an MCTS policy is better than either of the
leaf-node evaluator policies alone (Silver et al., 2016), yet
improved leaf-node evaluators also improve the quality of
MCTS (Gelly & Silver, 2007). The primary contributions
of this paper are summarized below.
1. We propose a batch, MCTS-based RL method that
operates on continuous state, finite action MDPs and
exploits the idea that leaf-evaluators can be updated
to produce a stronger tree search using previous tree
search results. Function approximators are used to
track policy and value function approximations, where
the latter is used to reduce the length of the tree search
rollout (oftentimes, the rollout of the policy becomes a
computational bottle-neck in complex environments).
2. We provide a full sample complexity analysis of the
method and show that with large enough sample sizes
and sufficiently large tree search effort, the performance of the estimated policies can be made close to
optimal, up to some unavoidable approximation error.
To our knowledge, batch MCTS-based RL methods
have not been theoretically analyzed.
3. An implementation of the feedback-based tree search
algorithm using deep neural networks is tested on
the recently popular MOBA game King of Glory (a
North American version of the same game is titled
Arena of Valor). The result is a competitive AI agent
for the 1v1 mode of the game.
2. Related Work
The idea of leveraging tree search during training was first
explored by Guo et al. (2014) in the context of Atari games,
where MCTS was used to generate offline training data for a
supervised learning (classification) procedure. The authors
showed that by using the power of tree search offline, the
resulting policy was able to outperform the deep Q-network
(DQN) approach of (Mnih et al., 2013). A natural next step
is to repeatedly apply the procedure of Guo et al. (2014).
In building AlphaGo Zero, Silver et al. (2017) extends the
ideas of Guo et al. (2014) into an iterative procedure, where
the neural network policy is updated after every episode
and then reincorporated into tree search. The technique was
able to produce a superhuman Go-playing AI (and improves
upon the previous AlphaGo versions) without any human
replay data.
Our proposed algorithm is a provably near-optimal variant
(and in some respects, generalization) of the AlphaGo Zero
algorithm. The key differences are the following: (1) our
theoretical results cover a continuous, rather than finite, state
space setting, (2) the environment is a stochastic MDP rather
than a sequential deterministic two player game, (3) we use
batch updates, (4) the feedback of previous results to the
leaf-evaluator manifests as both policy and value updates
rather than just the value (as Silver et al. (2017) does not
use policy rollouts).
Anthony et al. (2017) proposes a general framework called
expert iteration that combines supervised learning with tree
search-based planning. The methods described in Guo et al.
(2014), Silver et al. (2017), and the current paper can all
be (at least loosely) expressed under the expert iteration
framework. However, no theoretical insights were given
in any of these previous works and our paper intends to
fill this gap by providing a full theoretical analysis of an
iterative, MCTS-based RL algorithm. Our analysis relies
on the concentrability coefficient idea of Munos (2007) for
approximate value iteration and builds upon the work on
classification based policy iteration (Lazaric et al., 2016),
approximate modified policy iteration (Scherrer et al., 2015),
and fitted value iteration (Munos & Szepesvari ¬¥ , 2008).
Sample complexity results for MCTS are relatively sparse.
Teraoka et al. (2014) gives a high probability upper bound
on the number of playouts needed to achieve -accuracy
at the root node for a stylized version of MCTS called
FindTopWinner. More recently, Kaufmann & Koolen
(2017) provided high probability bounds on the sample
complexity of two other variants of MCTS called UGapEMCTS and LUCB-MCTS. In this paper, we do not require any
particular implementation of MCTS, but make a generic
assumption on its accuracy that is inspired by these results.
3. Problem Formulation
Consider a discounted, infinite-horizon MDP with a continuous state space S and finite action space A. For all
(s, a) ‚àà S √óA, the reward function r : S √óA ‚Üí R satisfies
r(s, a) ‚àà [0, Rmax]. The transition kernel, which describes
transitions to the next state given current state s and action a,
is written p(¬∑|s, a) ‚Äî a probability measure over S. Given
a discount factor Œ≥ ‚àà [0, 1), the value function V
œÄ of a
policy œÄ : S ‚Üí A starting in s = s0 ‚àà S is given by
V
œÄ
(s) = E
"X‚àû
t=0
Œ≥
t
r(st, œÄt(st))#
, (1)
Feedback-Based Tree Search for Reinforcement Learning
where st is the state visited at time t. Let Œ† be the set of
all stationary, deterministic policies (i.e., mappings from
state to action). The optimal value function is obtained by
maximizing over all policies: V
‚àó
(s) = supœÄ‚ààŒ† V
œÄ
(s).
Both V
œÄ
and V
‚àó
are bounded by Vmax = Rmax/(1‚àíŒ≥). We
let F be the set of bounded, real-valued functions mapping
S to [0, Vmax]. We frequently make use of the shorthand
operator TœÄ : F ‚Üí F, where the quantity (TœÄV )(s) is be
interpreted as the reward gained by taking an action according to œÄ, receiving the reward r(s, œÄ(s)), and then receiving
an expected terminal reward according to the argument V :
(TœÄV )(s) = r(s, œÄ(s)) + Œ≥
Z
S
V (Àús) p(dsÀú|s, œÄ(s)).
It is well-known that V
œÄ
is the unique fixed-point of TœÄ,
meaning TœÄV
œÄ = V
œÄ
(Puterman, 2014). The Bellman operator T : F ‚Üí F is similarly defined using the maximizing
action:
(T V )(s) = max
a‚ààA h
r(s, a) + Œ≥
Z
S
V (Àús) p(dsÀú|s, a)
i
.
It is also known that V
‚àó
is the unique fixed-point of T
(Puterman, 2014) and that acting greedily with respect to
the optimal value function V
‚àó produces an optimal policy:
œÄ
‚àó
(s) ‚àà arg max
a‚ààA
h
r(s, a) + Œ≥
Z
S
V
‚àó
(Àús) p(dsÀú|s, a)
i
.
We use the notation T
d
to mean the d compositions of the
mapping T, e.g., T
2V = T(T V ). Lastly, let V ‚àà F and let
ŒΩ be a distribution over S. We define left and right versions
of an operator PœÄ:
(PœÄV )(s) = Z
S
V (Àús) p(dsÀú|s, œÄ(s)),
(ŒΩPœÄ)(dsÀú) = Z
S
p(dsÀú|s, œÄ(s)) ŒΩ(ds).
Note that PœÄV ‚àà F and ¬µPœÄ is another distribution over S.
4. Feedback-Based Tree Search Algorithm
We now formally describe the proposed algorithm. The
parameters are as follows. Let Œ†¬Ø ‚äÜ Œ† be a space of approximate policies and F ‚äÜ F ¬Ø be a space of approximate value
functions (e.g., classes of neural network architectures). We
let œÄk ‚àà Œ†¬Ø be the policy function approximation (PFA)
and Vk ‚àà F¬Ø be the value function approximation (VFA) at
iteration k of the algorithm. Parameters subscripted with ‚Äò0‚Äô
are used in the value function approximation (regression)
phase and parameters subscripted with ‚Äò1‚Äô are used in the
tree search phase. The full description of the procedure is
given in Figure 1, using the notation Ta = TœÄa
, where œÄa
maps all states to the action a ‚àà A. We now summarize the
two phases, VFA (Steps 2 and 3) and MCTS (Steps 4, 5,
and 6).
VFA Phase. Given a policy œÄk, we wish to approximate
its value by fitting a function using subroutine Regress on
N0 states sampled from a distribution œÅ0. Each call to MCTS
requires repeatedly performing rollouts that are initiated
from leaf-nodes of the decision tree. Because repeating full
rollouts during tree search is expensive, the idea is that a
VFA obtained from a one-time regression on a single set
of rollouts can drastically reduce the computation needed
for MCTS. For each sampled state s, we estimate its value
using M0 full rollouts, which can be obtained using the
absorption time formulation of an infinite horizon MDP
(Puterman, 2014, Proposition 5.3.1).
MCTS Phase. On every iteration k, we sample a set of
N1 i.i.d. states from a distribution œÅ1 over S. From each
state, a tree search algorithm, denoted MCTS, is executed for
M1 iterations on a search tree of maximum depth d. We
assume here that the leaf evaluator is a general function
of the PFA and VFA from the previous iteration, œÄk and
Vk, and it is denoted as a ‚Äúsubroutine‚Äù LeafEval. The
results of the MCTS procedure are piped into a subroutine
Classify, which fits a new policy œÄk+1 using classification
(from continuous states to discrete actions) on the new data.
As discussed more in Assumption 4, Classify uses L1
observations (one-step rollouts) to compute a loss function.
1. Sample a set of N0 i.i.d. states S0,k from œÅ0 and N1 i.i.d.
states S1,k from œÅ1.
2. Compute a sample average YÀÜk(s) of M0 independent rollouts of œÄk for each s ‚àà S0,k. See Assumption 1.
3. Use Regress on the set {YÀÜk(s) : s ‚àà S0,k} to obtain a
value function Vk ‚àà F¬Ø. See Assumption 1.
4. From each s ‚àà S1,k, run MCTS with parameters M1, d,
and evaluator LeafEval. Return estimated value of each s,
denoted UÀÜk(s). See Assumptions 2 and 3.
5. For each s ‚àà S1,k and a ‚àà A, create estimate QÀÜk(s, a) ‚âà
(Ta Vk)(s) by averaging L1 transitions from p(¬∑|s, a). See
Assumption 4.
6. Use Classify to solve a cost-sensitive classification problem and obtain the next policy œÄk+1 ‚àà Œ†¬Ø . Costs are measured
using {UÀÜk(s) : s ‚àà S1,k} and {QÀÜk(s, œÄk+1(s)) : s ‚àà S1,k}.
See Assumption 4. Increment k and return to Step 1.
Figure 1. Feedback-Based Tree Search Algorithm
The illustration given in Figure 2 shows the interactions (and
feedback loop) of the basic components of the algorithm:
(1) a set of tree search runs initiated from a batch of sampled
states (triangles), (2) leaf evaluation using œÄk and Vk is used
during tree search, and (3) updated PFA and VFA œÄk+1 and
Feedback-Based Tree Search for Reinforcement Learning
S
s
1
s
2
s
N1 s ¬∑ ¬∑ ¬∑
3
leaf evaluation
update
œÄk and
Vk
œÄk+1 and Vk+1
tree search
Figure 2. Illustration of the Feedback Loop
Vk+1 using tree search results.
5. Assumptions
Figure 1 shows the algorithm written with general subroutines Regress, MCTS, LeafEval, and Classify, allowing
for variations in implementation suited for different problems. However, our analysis assumes specific choices and
properties of these subroutines, which we describe now. The
regression step solves a least absolute deviation problem to
minimize an empirical version of
kf ‚àí V
œÄk k1, œÅ0 =
Z
S
|f(s) ‚àí V
œÄk
(s)|œÅ0(ds),
as described in the first assumption.
Assumption 1 (Regress Subroutine). For each s
i ‚àà S0,k,
define s
i = s
ij
0
for all j and for each t, the state s
ij
t+1 is
drawn from p(¬∑|s
ij
t
, œÄk(s
ij
t
)). Let YÀÜ
k(s
i
) be an estimate of
V
œÄk (s
i
) using M0 rollouts and Vk, the VFA resulting from
Regress, obtained via least absolute deviation regression:
YÀÜ
k(s
i
0
) = 1
M0
X
M0
j=1
X‚àû
t=0
Œ≥
t
r(s
ij
t
, œÄk(s
ij
t
)), (2)
Vk ‚àà arg min
f‚ààF¬Ø
1
N0
X
N0
i=1

f(s
i
) ‚àí YÀÜ
k(s
i
)


. (3)
There are many ways that LeafEval may be defined. The
standard leaf evaluator for MCTS is to simulate a default
or ‚Äúrollout‚Äù policy (Browne et al., 2012) until the end of
the game, though in related tree search techniques, authors
have also opted for a value function approximation (Campbell et al., 2002; Enzenberger, 2004). It is also possible to
combine the two approximations: Silver et al. (2016) uses
a weighted combination of a full rollout from a pre-trained
policy and a pre-trained value function approximation.
Assumption 2 (LeafEval Subroutine). Our approach uses
a partial rollout of length h ‚â• 0 and a value estimation at
the end. LeafEval produces unbiased observations of
Jk(s) = E
"
h
X‚àí1
t=0
Œ≥
t
r(Àúst, œÄk(Àúst)) + Œ≥
h Vk(Àúsh)
#
, (4)
where sÀú0 = s.
Assumption 2 is motivated by our MOBA game, on which
we observed that even short rollouts (as opposed to simply
using a VFA) are immensely helpful in determining local
outcomes (e.g., dodging attacks, eliminating minions, health
regeneration). At the same time, we found that numerous
full rollouts simulated using the relatively slow and complex
game engine is far too time-consuming within tree search.
We also need to make an assumption on the sample complexity of MCTS, of which there are many possible variations
(Chaslot et al., 2006; Coulom, 2006; Kocsis & Szepesvari ¬¥ ,
2006; Gelly & Silver, 2007; Couetoux et al. ¬® , 2011a;b; AlKanj et al., 2016; Jiang et al., 2017). Particularly relevant to
our continuous-state setting are tree expansion techniques
called progressive widening and double progressive widening, proposed in Couetoux et al. ¬® (2011a), which have proven
successful in problems with continuous state/action spaces.
To our knowledge, analysis of the sample complexity is only
available for stylized versions of MCTS on finite problems,
like Teraoka et al. (2014) and Kaufmann & Koolen (2017).
Theorems from these papers show upper bounds on the number of iterations needed so that with high probability (greater
than 1 ‚àí Œ¥), the value at the root node is accurate within
a tolerance of . Fortunately, there are ways to discretize
continuous state MDPs that enjoy error guarantees, such as
Bertsekas (1975), Dufour & Prieto-Rumeau (2012), or Saldi
et al. (2017). These error bounds can be combined with the
MCTS guarantees of Teraoka et al. (2014) and Kaufmann
& Koolen (2017) to produce a sample complexity bound
for MCTS on continuous problems. The next assumption
captures the essence of these results (and if desired, can
be made precise for specific implementations through the
references above).
Assumption 3 (MCTS Subroutine). Consider a d-stage,
finite-horizon subproblem of (1) with terminal value function J and initial state is s. Let the result of MCTS be denoted
UÀÜ(s). We assume that there exists a function m(, Œ¥), such
that if m(, Œ¥) iterations of MCTS are used, the inequality
|UÀÜ(s)‚àí(T
d J)(s)| ‚â§  holds with probability at least 1‚àíŒ¥.
Now, we are ready to discuss the Classify subroutine.
Our goal is to select a policy œÄ ‚àà Œ†¬Ø that closely mimics the
performance of the MCTS result, similar to practical implementations in existing work (Guo et al., 2014; Silver et al.,
2017; Anthony et al., 2017). The question is: given a candidate œÄ, how do we measure ‚Äúcloseness‚Äù to the MCTS policy?
We take inspiration from previous work in classificationbased RL and use a cost-based penalization of classification
Feedback-Based Tree Search for Reinforcement Learning
errors (Langford & Zadrozny, 2005; Li et al., 2007; Lazaric
et al., 2016). Since UÀÜ(s
i
) is an approximation of the performance of the MCTS policy, we should try to select a policy
œÄ with similar performance. To estimate the performance
of some candidate policy œÄ, we use a one-step rollout and
evaluate the downstream cost using Vk.
Assumption 4 (Classify Subroutine). For each s
i ‚àà S1,k
and a ‚àà A, let QÀÜ
k(s
i
, a) be an estimate of the value of stateaction pair (s
i
, a) using L1 samples.
QÀÜ
k(s
i
, a) = 1
L1
X
L1
j=1

r(s
i
, a) + Œ≥ Vk(Àús
j
(a))
.
Let œÄk+1, the result of Classify, be obtained by minimizing the discrepancy between the MCTS result UÀÜ
k and the
estimated value of the policy under approximations QÀÜ
k:
œÄk+1 ‚àà arg min
œÄ‚ààŒ†¬Ø
1
N1
X
N1
i=1

UÀÜ
k(s
i
) ‚àí QÀÜ
k(s
i
, œÄ(s
i
))


,
where sÀú
j
(a) are i.i.d. samples from p(¬∑ | s
i
, a).
An issue that arises during the analysis is that even though
we can control the distribution from which states are sampled, this distribution is transformed by the transition kernel
of the policies used for rollout/lookahead. Let us now introduce the concentrability coefficient idea of Munos (2007)
(and used subsequently by many authors, including Munos
& Szepesvari ¬¥ (2008), Lazaric et al. (2016), Scherrer et al.
(2015), and Haskell et al. (2016)).
Assumption 5 (Concentrability). Consider any sequence
of m policies ¬µ1, ¬µ2, . . . , ¬µm ‚àà Œ†. Suppose we start in
distribution ŒΩ and that the state distribution attained after
applying the m policies in succession, ŒΩ P¬µ1 P¬µ2
¬∑ ¬∑ ¬∑ P¬µm,
is absolutely continuous with respect to œÅ1. We define an
m-step concentrability coefficient
Am = sup
¬µ1, ...,¬µm








dŒΩP¬µ1 P¬µ2
¬∑ ¬∑ ¬∑ P¬µm
dœÅ1








‚àû
,
and assume that P‚àû
i,j=0 Œ≥
i+j Ai+j < ‚àû. Similarly, we
assume œÅ1P¬µ1 P¬µ2
¬∑ ¬∑ ¬∑ P¬µm, is absolutely continuous with
respect to œÅ0 and assume that
A
0
m = sup
¬µ1, ...,¬µm








dœÅ1P¬µ1 P¬µ2
¬∑ ¬∑ ¬∑ P¬µm
dœÅ0








‚àû
is finite for any m.
The concentrability coefficient describes how the state distribution changes after m steps of arbitrary policies and how
it relates to a given reference distribution. Assumptions 1-5
are used for the remainder of the paper.
6. Sample Complexity Analysis
Before presenting the sample complexity analysis, let us
consider an algorithm that generates a sequence of policies {œÄ0, œÄ1, œÄ2, . . .} satisfying TœÄk+1 T
d‚àí1V
œÄk = T
d V
œÄk
with no error. It is proved in Bertsekas & Tsitsiklis (1996,
pp. 30-31) that œÄk ‚Üí œÄ
‚àó
in the finite state and action setting. Our proposed algorithm in Figure 1 can be viewed as
approximately satisfying this iteration in a continuous state
space setting, where MCTS plays the role of T
d
and evaluation of œÄk uses a combination of accurate rollouts (due
to Classify) and fast VFA evaluations (due to Regress).
The sample complexity analysis requires the effects of all
errors to be systematically analyzed.
For some K ‚â• 0, our goal is to develop a high probability
upper bound on the expected suboptimality, over an initial
state distribution ŒΩ, of the performance of policy œÄK, written as kV
‚àó ‚àí V
œÄK k1,ŒΩ. Because there is no requirement to
control errors with probability one, bounds in k¬∑ k1,ŒΩ tend to
be much more useful in practice than ones in the traditional
k ¬∑ k‚àû. Notice that:
1
N1
X
N1
i=1

UÀÜ
k(s
i
) ‚àí QÀÜ
k(s
i
, œÄk+1(s
i
))


‚âà



T
d V
œÄk ‚àí TœÄk+1 V
œÄk




1,œÅ1
,
(5)
where the left-hand-side is the loss function used in the
classification step from Assumption 4. It turns out that
we can relate the right-hand-side (albeit under a different
distribution) to the expected suboptimality after K iterations
kV
‚àó ‚àí V
œÄK k1,ŒΩ, as shown in the following lemma. Full
proofs of all results are given in the supplementary material.
Lemma 1 (Loss to Performance Relationship). The expected suboptimality of œÄK can be bounded as follows:
kV
‚àó‚àíV
œÄK k1,ŒΩ ‚â§ Œ≥
K d kV
‚àó ‚àí V
œÄ0 k‚àû
+
X
K
k=1
Œ≥
(K‚àík)d



T
d V
œÄk‚àí1 ‚àí TœÄk V
œÄk‚àí1




1,ŒõŒΩ,k
where ŒõŒΩ,k = ŒΩ (PœÄ‚àó )
(K‚àík)d

I ‚àí (Œ≥PœÄk
)
‚àí1
.
From Lemma 1, we see that the expected suboptimality at iteration K can be upper bounded by the suboptimality of the initial policy œÄ0 (in maximum norm) plus
a discounted and re-weighted version of kT
d V
œÄk‚àí1 ‚àí
TœÄk V
œÄk‚àí1 k1,œÅ1
accumulated over prior iterations. Hypothetically, if (T
d V
œÄk‚àí1 )(s) ‚àí (TœÄk V
œÄk‚àí1 )(s) were small
for all iterations k and all states s, then the suboptimality
of œÄK converges linearly to zero. Hence, we may refer to
kT
d V
œÄk‚àí1 ‚àí TœÄk V
œÄk‚àí1 k1,œÅ1
as the ‚Äútrue loss,‚Äù the target
term to be minimized at iteration k. We now have a starting
point for the analysis: if (5) can be made precise, then the
result can be combined with Lemma 1 to provide an explicit
Feedback-Based Tree Search for Reinforcement Learning
!
! T
d V
œÄk ‚àí TœÄk+1 V
œÄk
!
!
1, œÅ1
!
! V
k ‚àí V
œÄk
!
!
1, œÅ0
!
! T
dJk ‚àí TœÄk+1 Vk
!
!
1, œÅ1
state space sampling
approximation over F¬Ø B
‚Ä≤
Œ≥ min
f‚ààF¬Ø
!f ‚àí V
œÄk !1, œÅ0
additional error «´
min
œÄ‚ààŒ†¬Ø
!T
d V
œÄk ‚àí TœÄ V
œÄk !1, œÅ1
state/rollout sampling
approximation over Œ†¬Ø
‚Äútrue loss of œÄk+1‚Äù
tree search error
Figure 3. Various Errors Analyzed in Lemma 3
bound on kV
‚àó ‚àí V
œÄK k1,ŒΩ. The various errors that we incur
when relating the objective of Classify to the true loss
include the error due to regression using functions in F¬Ø; the
error due to sampling the state space according to œÅ1; the
error of estimating (TœÄ Vk)(s) using the sample average of
one-step rollouts QÀÜ
k(s, œÄ(s)); and of course, the error due
to MCTS.
We now give a series of lemmas that help us carry out
the analysis. In the algorithmic setting, the policy œÄk is a
random quantity that depends on the samples collected in
previous iterations; however, for simplicity, the lemmas that
follow are stated from the perspective of a fixed policy ¬µ or
fixed value function approximation V rather than œÄk or Vk.
Conditioning arguments will be used when invoking these
lemmas (see supplementary material).
Lemma 2 (Propagation of VFA Error). Consider a policy
¬µ ‚àà Œ† and value function V ‚àà F. Analogous to (4), let
J = T
h
¬µ V . Then, under Assumption 5, we have the bounds:
(a) supœÄ‚ààŒ†¬Ø kTœÄ V ‚àí TœÄ V
¬µk1,œÅ1 ‚â§ Œ≥ A0
1 kV ‚àí V
¬µk1,œÅ0
,
(b) kT
d J ‚àí T
d V
¬µk1,œÅ1 ‚â§ Œ≥
d+hA0
d+h
kV ‚àí V
¬µk1,œÅ0
.
The lemma above addresses the fact that instead of using
V
œÄk directly, Classify and MCTS only have access to the
estimates Vk and Jk = T
h
œÄk
Vk (h steps of rollout with an
evaluation of Vk at the end), respectively. Note that propagation of the error in Vk is discounted by Œ≥ or Œ≥
d+h
and
since the lemma converts between k ¬∑ k1,œÅ1
and k ¬∑ k1,œÅ0
, it
is also impacted by the concentrability coefficients A0
1
and
A0
d+h
.
Let dŒ†¬Ø be the VC-dimension of the class of binary classifiers
Œ†¬Ø and let dF¬Ø be the pseudo-dimension of the function class
F¬Ø. The VC-dimension is a measure of the capacity of Œ†¬Ø and
the notion of a pseudo-dimension is a generalization of the
VC-dimension to real-valued functions (see, e.g., Pollard
(1990), Haussler (1992), Mohri et al. (2012) for definitions
of both). Similar to Lazaric et al. (2016) and Scherrer et al.
(2015), we will present results for the case of two actions,
i.e., |A| = 2. The extension to multiple actions is possible
by performing an analysis along the lines of Lazaric et al.
(2016, Section 6). We now quantify the error illustrated in
Figure 3. Define the quantity B0
Œ≥ = Œ≥ A0
1 + Œ≥
d+hA0
d+h
, the
sum of the coefficients from Lemma 2.
Lemma 3. Suppose the regression sample size N0 is
O

(VmaxB
0
Œ≥
)
2

‚àí2

log(1/Œ¥) + dF¬Ø log(VmaxB
0
Œ≥/)

and the sample size M0, for estimating the regression targets, is
O

(VmaxB
0
Œ≥
)
2

‚àí2

log(N0/Œ¥)
 .
Furthermore, there exist constants C1, C2, C3, and C4, such
that if N1 and L1 are large enough to satisfy
N1 ‚â• C1V
2
max 
‚àí2

log(C2/Œ¥) + dŒ†¬Ø log(eN1/dŒ†¬Ø )

,
L1 ‚â• C1V
2
max 
‚àí2

log(C2N1/Œ¥) + dŒ†¬Ø log(eL1/dŒ†¬Ø )

,
and if M1 ‚â• m(C3 , C4 Œ¥/N1), then
kT
d V
œÄk ‚àí TœÄk+1 V
œÄk k1,œÅ1 ‚â§ B
0
Œ≥ min
f‚ààF¬Ø
kf ‚àí V
œÄk k1,œÅ0
+ min
œÄ‚ààŒ†¬Ø
kT
d V
œÄk ‚àí TœÄ V
œÄk k1,œÅ1 + 
with probability at least 1 ‚àí Œ¥.
Sketch of Proof. By adding and subtracting terms, applying
the triangle inequality, and invoking Lemma 2, we see that:
kT
d V
œÄk ‚àí TœÄk+1 V
œÄk k1,œÅ1 ‚â§ B
0
Œ≥ kVk ‚àí V
œÄk k1,œÅ0
+ kT
dJk ‚àí TœÄk+1 Vkk1,œÅ1
,
Here, the error is split into two terms. The first depends on
the sample S0,k and the history through œÄk while the second
term depends on the sample S1,k and the history through Vk.
We can thus view œÄk as fixed when analyzing the first term
and Vk as fixed when analyzing the second term (details in
the supplementary material). The first term kVk ‚àíV
œÄk k1,œÅ0
contributes the quantity minf‚ààF¬Ø kf ‚àí V
œÄk k1,œÅ0
in the final
bound with additional estimation error contained within .
The second term kT
dJk‚àíTœÄk+1 Vkk1,œÅ1
contributes the rest.
See Figure 3 for an illustration of the main proof steps.
The first two terms on the right-hand-side are related to the
approximation power of F¬Ø and Œ†¬Ø and can be considered
unavoidable. We upper-bound these terms by maximizing
over Œ†¬Ø, in effect removing the dependence on the random
process œÄk in the analysis of the next theorem. We define:
D0(Œ†¬Ø, F¬Ø) = max
œÄ‚ààŒ†¬Ø
min
f‚ààF¬Ø
kf ‚àí V
œÄ
k1,œÅ0
,
D
d
1
(Œ†) = max ¬Ø
œÄ‚ààŒ†¬Ø
min
œÄ0‚ààŒ†¬Ø
kT
d V
œÄ ‚àí TœÄ0 V
œÄ
k1,œÅ1
Feedback-Based Tree Search for Reinforcement Learning
Figure 4. Screenshot from 1v1 King of Glory
two terms that are closely related to the notion of inherent
Bellman error (Antos et al., 2008; Munos & Szepesvari ¬¥ ,
2008; Lazaric et al., 2016; Scherrer et al., 2015; Haskell
et al., 2017). Also, let BŒ≥ =
P‚àû
i,j=0 Œ≥
i+j Ai+j , which was
assumed to be finite in Assumption 5.
Theorem 1. Suppose the sample size requirements of
Lemma 3 are satisfied with /BŒ≥ and Œ¥/K replacing  and
Œ¥, respectively. Then, the suboptimality of the policy œÄK
can be bounded as follows:
kV
‚àó ‚àí V
œÄK k1,ŒΩ ‚â§ BŒ≥ [B
0
Œ≥ D0(Œ†¬Ø , F¬Ø) + D
d
1
(Œ†)] ¬Ø
+ Œ≥
Kd kV
‚àó ‚àí V
œÄ0 k‚àû + ,
with probability at least 1 ‚àí Œ¥.
Search Depth. How should the search depth d be chosen?
Theorem 1 shows that as d increases, fewer iterations K
are needed to achieve a given accuracy; however, the effort
required of tree search (i.e., the function m(, Œ¥)) grows
exponentially in d. At the other extreme (d = 1), more iterations K are needed and the ‚Äúfixed cost‚Äù of each iteration
of the algorithm (i.e., sampling, regression, and classification ‚Äî all of the steps that do not depend on d) becomes
more prominent. For a given problem and algorithm parameters, these computational costs can each be estimated and
Theorem 1 can serve as a guide to selecting an optimal d.
7. Case Study: King of Glory MOBA AI
We implemented Feedback-Based Tree Search within a new
and challenging environment, the recently popular MOBA
game King of Glory by Tencent (the game is also known
as Honor of Kings and a North American release of the
game is titled Arena of Valor). Our implementation of the
algorithm is one of the first attempts to design an AI for the
1v1 version of this game.
Game Description. In the King of Glory, players are divided into two opposing teams and each team has a base
located on the opposite corners of the game map (similar
to other MOBA games, like League of Legends or Dota 2).
The bases are guarded by towers, which can attack the enemies when they are within a certain attack range. The goal
of each team is to overcome the towers and eventually destroy the opposing team‚Äôs ‚Äúcrystal,‚Äù located at the enemy‚Äôs
base. For this paper, we only consider the 1v1 mode, where
each player controls a primary ‚Äúhero‚Äù alongside less powerful game-controlled characters called ‚Äúminions.‚Äù These
units guard the path to the crystal and will automatically fire
(weak) attacks at enemies within range. Figure 4 shows the
two heroes and their minions; the upper-left corner shows
the map, with the blue and red markers pinpointing the
towers and crystals.
Experimental Setup. The state variable of the system is
taken to be a 41-dimensional vector containing information
obtained directly from the game engine, including hero
locations, hero health, minion health, hero skill states, and
relative locations to various structures. There are 22 actions,
including move, attack, heal, and special skill actions, some
of which are associated with (discretized) directions. The
reward function is designed to mimic reward shaping (Ng
et al., 1999) and uses a combination of signals including
health, kills, damage dealt, and proximity to crystal. We
trained five King of Glory agents, using the hero DiRenJie:
1. The ‚ÄúFBTS‚Äù agent is trained using our feedback-based
tree search algorithm for K = 7 iterations of 50 games
each. The search depth is d = 7 and rollout length is
h = 5. Each call to MCTS ran for 400 iterations.
2. The second agent is labeled ‚ÄúNR‚Äù for no rollouts. It
uses the same parameters as the FBTS agent except
no rollouts are used. At a high level, this bears some
similarity to the AlphaGo Zero algorithm (Silver et al.,
2017) in a batch setting.
3. The ‚ÄúDPI‚Äù agent uses the direct policy iteration technique of (Lazaric et al., 2016) for K = 10 iterations.
There is no value function and no tree search (due to
computational limitations, more iterations are possible
when tree search is not used).
4. We then have the ‚ÄúAVI‚Äù agent, which implements approximate value iteration (De Farias & Van Roy, 2000;
Van Roy, 2006; Munos, 2007; Munos & Szepesvari ¬¥ ,
2008) for K = 10 iterations. This algorithm can be
considered a batch version of DQN (Mnih et al., 2013).
5. Lastly, we consider an ‚ÄúSL‚Äù agent trained via supervised learning on a dataset of approximately 100,000
state/action pairs of human gameplay data. Notably,
the policy architecture used here is consistent with the
previous agents.
In fact, both the policy and value function approximations
are consistent across all agents; they use fully-connected
Feedback-Based Tree Search for Reinforcement Learning
neural networks with five and two hidden layers, respectively, and SELU (scaled exponential linear unit) activation
(Klambauer et al., 2017). The initial policy œÄ0 takes random
actions: move (w.p. 0.5), directional attack (w.p. 0.2), or a
special skill (w.p. 0.3). Besides biasing the move direction
toward the forward direction, no other heuristic information is used by œÄ0. MCTS was chosen to be a variant of
UCT (Kocsis & Szepesvari ¬¥ , 2006) that is more amenable toward parallel simulations: instead of using the argmax of the
UCB scores, we sample actions according to the distribution
obtained by applying softmax to the UCB scores.
In the practical implementation of the algorithm, Regress
uses a cosine proximity loss while Classify uses a negative log-likelihood loss, differing from the theoretical specifications. Due to the inability to ‚Äúrewind‚Äù or ‚Äúfast-forward‚Äù
the game environment to arbitrary states, the sampling distribution œÅ0 is implemented by first taking random actions (for
a random number of steps) to arrive at an initial state and
then following œÄk until the end of the game. To reduce correlation during value approximation, we discard 2/3 of the
states encountered in these trajectories. For œÅ1, we follow
the MCTS policy while occasionally injecting noise (in the
form of random actions and random switches to the default
policy) to reduce correlation. During rollouts, we use the
internal AI for the hero DiRenJie as the opponent.
Results. As the game is nearly deterministic, our primary
methodology for testing to compare the agents‚Äô effectiveness against a common set of opponents chosen from the
internal AIs. We also added the internal DiRenJie AI as a
‚Äúsanity check‚Äù baseline agent. To select the test opponents,
we played the internal DiRenJie AI against other internal
AIs (i.e., other heroes) and selected six heroes of the marksman type that the internal DiRenJie AI is able to defeat.
Each of our agents, including the internal DiRenJie AI, was
then played against every test opponent. Figure 5 shows the
length of time, measured in frames, for each agent to defeat
the test opponents (a value of 20,000 frames is assigned
if the opponent won). Against the set of common opponents, FBTS significantly outperforms DPI, AVI, SL, and
0.0 0.2 0.4 0.6 0.8 1.0
Fraction of Game
0.5
1.0
1.5
2.0
Gold Ratio
vs. NR vs. DPI vs. AVI vs. SL
Figure 6. In-game Behavior
the internal AI. However, FBTS only slightly outperforms
NR on average (which is perhaps not surprising as NR is
the only other agent that also uses MCTS). Our second set
of results help to visualize head-to-head battles played between FBTS and the four baselines (all of which are won
by FBTS): Figure 6 shows the ratio of the FBTS agent‚Äôs
gold to its opponent‚Äôs gold as a function of time. Gold is
collected throughout the game as heroes deal damage and
defeat enemies, so a ratio above 1.0 (above the red region)
indicates good relative performance by FBTS. As the figure
shows, each game ends with FBTS achieving a gold ratio in
the range of [1.25, 1.75].
8. Conclusion & Future Work
In this paper, we provide a sample complexity analysis
for feedback-based tree search, an RL algorithm based on
repeatedly solving finite-horizon subproblems using MCTS.
Our primary methodological avenues for future work are
(1) to analyze a self-play variant of the algorithm and (2)
to consider related techniques in multi-agent domains (see,
e.g., Hu & Wellman (2003)). The implementation of the
algorithm in the 1v1 MOBA game King of Glory provided
us encouraging results against several related algorithms;
however, significant work remains for the agent to become
competitive with humans.
vs. Hero 1 vs. Hero 2 vs. Hero 3 vs. Hero 4 vs. Hero 5 vs. Hero 6 Average
0
5
10
15
Loss
Frames until Win (x 1000)
FBTS NR DPI AVI SL Internal AI
Figure 5. Number of Frames to Defeat Marksman Heroes
Feedback-Based Tree Search for Reinforcement Learning
Acknowledgements
We sincerely appreciate the helpful feedback from four
anonymous reviewers, which helped to significantly improve the paper. We also wish to thank our colleagues at
Tencent AI Lab, particularly Carson Eisenach and Xiangru
Lian, for assistance with the test environment and for providing the SL agent. The first author is very grateful for the
support from Tencent AI Lab through a faculty award.
References
Al-Kanj, Lina, Powell, Warren B, and Bouzaiene-Ayari,
Belgacem. The information-collecting vehicle routing
problem: Stochastic optimization for emergency storm
response. arXiv preprint arXiv:1605.05711, 2016.
Anthony, Thomas, Tian, Zheng, and Barber, David. Thinking fast and slow with deep learning and tree search. In
Advances in Neural Information Processing Systems, pp.
5366‚Äì5376, 2017.
Antos, Andras, Szepesv ¬¥ ari, Csaba, and Munos, R ¬¥ emi. Learn- ¬¥
ing near-optimal policies with bellman-residual minimization based fitted policy iteration and a single sample path.
Machine Learning, 71(1):89‚Äì129, 2008.
Bertsekas, Dimitri P. Convergence of discretization procedures in dynamic programming. IEEE Transactions on
Automatic Control, 20(3):415‚Äì419, 1975.
Bertsekas, Dimitri P and Tsitsiklis, John N. Neuro-dynamic
Programming. Athena Scientific, Belmont, MA, 1996.
Browne, Cameron B, Powley, Edward, Whitehouse, Daniel,
Lucas, Simon M, Cowling, Peter I, Rohlfshagen, Philipp,
Tavener, Stephen, Perez, Diego, Samothrakis, Spyridon,
and Colton, Simon. A survey of monte carlo tree search
methods. IEEE Transactions on Computational Intelligence and AI in games, 4(1):1‚Äì43, 2012.
Campbell, Murray, Hoane Jr, A Joseph, and Hsu, Fenghsiung. Deep blue. Artificial Intelligence, 134(1-2):57‚Äì
83, 2002.
Cazenave, Tristan. Nested Monte-Carlo search. In International Joint Conference on Artificial Intelligence, pp.
456‚Äì461, 2009.
Chaslot, Guillaume, Saito, Jahn-Takeshi, Uiterwijk,
Jos WHM, Bouzy, Bruno, and van den Herik, H Jaap.
Monte-Carlo strategies for computer Go. In 18th BelgianDutch Conference on Artificial Intelligence, pp. 83‚Äì90,
2006.
Chaslot, Guillaume, Bakkes, Sander, Szita, Istvan, and
Spronck, Pieter. Monte-carlo tree search: A new framework for game AI. In AAAI Conference on Artificial
Intelligence and Interactive Digital Entertainment, 2008.
Couetoux, Adrien, Hoock, Jean-Baptiste, Sokolovska, Na- ¬®
taliya, Teytaud, Olivier, and Bonnard, Nicolas. Continuous upper confidence trees. In International Conference
on Learning and Intelligent Optimization, pp. 433‚Äì445.
Springer, 2011a.
Couetoux, Adrien, Milone, Mario, Brendel, M ¬® aty ¬¥ as, Dogh- ¬¥
men, Hassan, Sebag, Michele, and Teytaud, Olivier. Continuous rapid action value estimates. In Asian Conference
on Machine Learning, pp. 19‚Äì31, 2011b.
Coulom, Remi. Efficient selectivity and backup operators ¬¥
in Monte-Carlo tree search. In International Conference
on Computers and Games, pp. 72‚Äì83, 2006.
De Farias, D Pucci and Van Roy, Benjamin. On the existence of fixed points for approximate value iteration and
temporal-difference learning. Journal of Optimization
theory and Applications, 105(3):589‚Äì608, 2000.
Dufour, Franc¬∏ois and Prieto-Rumeau, Tomas. Approxi- ¬¥
mation of markov decision processes with general state
space. Journal of Mathematical Analysis and Applications, 388(2):1254‚Äì1267, 2012.
Enzenberger, Markus. Evaluation in go by a neural network using soft segmentation. In Advances in Computer
Games, pp. 97‚Äì108. Springer, 2004.
Gelly, Sylvain and Silver, David. Combining online and
offline knowledge in UCT. In Proceedings of the 24th
International Conference on Machine learning, pp. 273‚Äì
280, 2007.
Gelly, Sylvain and Silver, David. Monte-carlo tree search
and rapid action value estimation in computer Go. Artificial Intelligence, 175(11):1856‚Äì1875, 2011.
Gelly, Sylvain, Kocsis, Levente, Schoenauer, Marc, Sebag,
Michele, Silver, David, Szepesvari, Csaba, and Teytaud, ¬¥
Olivier. The grand challenge of computer Go: Monte
Carlo tree search and extensions. Communications of the
ACM, 55(3):106‚Äì113, 2012.
Guo, Xiaoxiao, Singh, Satinder, Lee, Honglak, Lewis,
Richard L, and Wang, Xiaoshi. Deep learning for realtime Atari game play using offline Monte-Carlo tree
search planning. In Advances in Neural Information
Processing Systems, pp. 3338‚Äì3346, 2014.
Haskell, William B, Jain, Rahul, and Kalathil, Dileep. Empirical dynamic programming. Mathematics of Operations Research, 41(2):402‚Äì429, 2016.
Haskell, William B, Jain, Rahul, Sharma, Hiteshi, and Yu,
Pengqian. An empirical dynamic programming algorithm
for continuous MDPs. arXiv preprint arXiv:1709.07506,
2017.
Feedback-Based Tree Search for Reinforcement Learning
Haussler, David. Decision theoretic generalizations of the
PAC model for neural net and other learning applications.
Information and Computation, 100(1):78‚Äì150, 1992.
Hingston, Philip and Masek, Martin. Experiments with
Monte Carlo Othello. In IEEE Congress on Evolutionary
Computation, pp. 4059‚Äì4064. IEEE, 2007.
Hu, Junling and Wellman, Michael P. Nash Q-learning
for general-sum stochastic games. Journal of Machine
Learning Research, 4(Nov):1039‚Äì1069, 2003.
Jiang, Daniel R, Al-Kanj, Lina, and Powell, Warren B.
Monte carlo tree search with sampled information relaxation dual bounds. arXiv preprint arXiv:1704.05963,
2017.
Kaufmann, Emilie and Koolen, Wouter. Monte-Carlo tree
search by best arm identification. In Advances in Neural
Information Processing Systems, pp. 4904‚Äì4913, 2017.
Klambauer, Gunter, Unterthiner, Thomas, Mayr, Andreas, ¬®
and Hochreiter, Sepp. Self-normalizing neural networks.
In Advances in Neural Information Processing Systems,
pp. 972‚Äì981, 2017.
Kocsis, Levente and Szepesvari, Csaba. Bandit based ¬¥
Monte-Carlo planning. In European Conference on Machine Learning, pp. 282‚Äì293, 2006.
Langford, John and Zadrozny, Bianca. Relating reinforcement learning performance to classification performance.
In Proceedings of the 22nd International Conference on
Machine Learning, pp. 473‚Äì480, 2005.
Lazaric, Alessandro, Ghavamzadeh, Mohammad, and
Munos, Remi. Analysis of classification-based policy ¬¥
iteration algorithms. Journal of Machine Learning Research, 17(19):1‚Äì30, 2016.
Li, Lihong, Bulitko, Vadim, and Greiner, Russell. Focus of
attention in reinforcement learning. Journal of Universal
Computer Science, 13(9):1246‚Äì1269, 2007.
MaÀÜƒ±trepierre, Raphael, Mary, J ¬® er¬¥ emie, and Munos, R ¬¥ emi. ¬¥
Adaptative play in Texas hold‚Äôem poker. In European
Conference on Artificial Intelligence, 2008.
Mehat, Jean and Cazenave, Tristan. Combining UCT and ¬¥
nested Monte Carlo search for single-player general game
playing. IEEE Transactions on Computational Intelligence and AI in Games, 2(4):271‚Äì277, 2010.
Mnih, Volodymyr, Kavukcuoglu, Koray, Silver, David,
Graves, Alex, Antonoglou, Ioannis, Wierstra, Daan, and
Riedmiller, Martin. Playing Atari with deep reinforcement learning. arXiv preprint arXiv:1312.5602, 2013.
Mohri, Mehryar, Rostamizadeh, Afshin, and Talwalkar,
Ameet. Foundations of Machine Learning. MIT Press,
2012.
Munos, Remi. Performance bounds in l ¬¥ p-norm for approximate value iteration. SIAM Journal on Control and
Optimization, 46(2):541‚Äì561, 2007.
Munos, Remi and Szepesv ¬¥ ari, Csaba. Finite-time bounds ¬¥
for fitted value iteration. Journal of Machine Learning
Research, 9(May):815‚Äì857, 2008.
Ng, Andrew Y, Harada, Daishi, and Russell, Stuart. Policy
invariance under reward transformations: Theory and
application to reward shaping. In Proceedings of the
16th International Conference on Machine Learning, pp.
278‚Äì287, 1999.
Pollard, David. Empirical processes: Theory and applications. In NSF-CBMS Regional Conference Series in
Probability and Statistics, pp. i‚Äì86. JSTOR, 1990.
Puterman, Martin L. Markov Decision Processes: Discrete
Stochastic Dynamic Programming. John Wiley & Sons,
2014.
Saldi, Naci, Yuksel, Serdar, and Linder, Tam ¬® as. On the ¬¥
asymptotic optimality of finite approximations to markov
decision processes with Borel spaces. Mathematics of
Operations Research, 42(4):945‚Äì978, 2017.
Scherrer, Bruno, Ghavamzadeh, Mohammad, Gabillon, Victor, Lesner, Boris, and Geist, Matthieu. Approximate
modified policy iteration and its application to the game
of tetris. Journal of Machine Learning Research, 16
(Aug):1629‚Äì1676, 2015.
Silver, D., Huang, A., Maddison, C. J., Guez, A., Sifre, L.,
van den Driessche, G., Schrittwieser, J., Antonoglou, I.,
Panneershelvam, V., Lanctot, M., Dieleman, S., Grewe,
D., Nham, J., Kalchbrenner, N., Sutskever, I., Lillicrap, T.,
Leach, M., Kavukcuoglu, K., Graepel, T., and Hassabis,
D. Mastering the game of Go with deep neural networks
and tree search. Nature, 529(7587):484‚Äì489, 2016.
Silver, David, Schrittwieser, Julian, Simonyan, Karen,
Antonoglou, Ioannis, Huang, Aja, Guez, Arthur, Hubert,
Thomas, Baker, Lucas, Lai, Matthew, Bolton, Adrian,
et al. Mastering the game of go without human knowledge. Nature, 550(7676):354, 2017.
Teraoka, Kazuki, Hatano, Kohei, and Takimoto, Eiji. Efficient sampling method for Monte Carlo tree search problem. IEICE Transactions on Information and Systems, 97
(3):392‚Äì398, 2014.
Van Roy, Benjamin. Performance loss bounds for approximate value iteration with state aggregation. Mathematics
of Operations Research, 31(2):234‚Äì244, 2006.
Supplementary Material for
Feedback-Based Tree Search for Reinforcement Learning
Daniel R. Jiang, Emmanuel Ekwedike, Han Liu
A Outline
Section B contains the proofs for the results stated in the main paper.
‚Ä¢ The proofs of Lemma 1 and Lemma 2 from the main paper are given in Sections B.1
and B.2. These two lemmas are important in that they provide the main structure
for the sample complexity analysis. The bounds hold pointwise.
‚Ä¢ In Section B.3, we provide some additional lemmas that are omitted from the main
paper.
‚Ä¢ Section B.4 gives the proof of Lemma 3 from the main paper, which makes use of
Lemma 2 and the results from Section B.3.
‚Ä¢ We prove the main result, Theorem 1, in Section B.5.
Lastly, in Section C, we provide additional implementation details regarding the neural
network architecture, state features, and computation.
1
Feedback-Based Tree Search for Reinforcement Learning
B Proofs
B.1 Proof of Lemma 1
This proof is a modification of arguments used in [Lazaric et al., 2016, Equation 8 and
Theorem 7]. By the fixed point property of TœÄk+1 and the definition of the Bellman operator
T, we have V
œÄk ‚àí V
œÄk+1 ‚â§ T
dV
œÄk ‚àí TœÄk+1 V
œÄk+1 . Subtracting and adding TœÄk+1 V
œÄk :
V
œÄk ‚àí V
œÄk+1 ‚â§ T
dV
œÄk ‚àí TœÄk+1 V
œÄk + TœÄk+1 V
œÄk ‚àí TœÄk+1 V
œÄk+1
‚â§ T
dV
œÄk ‚àí TœÄk+1 V
œÄk + (Œ≥PœÄk+1 )

V
œÄk ‚àí V
œÄk+1 
. (B.1)
Similarly, we will bound the difference between V
‚àó and V
œÄk+1 in terms of the distances
between V
‚àó ‚àí V
œÄk and V
œÄk ‚àí V
œÄk+1 :
V
‚àó ‚àí V
œÄk+1 ‚â§ (Œ≥PœÄ‚àó )
d

V
‚àó ‚àí V
œÄk

+ T
dV
œÄk ‚àí TœÄk+1 V
œÄk + (Œ≥PœÄk+1 )

V
œÄk ‚àí V
œÄk+1 
. (B.2)
Using the bound V
œÄk ‚àí V
œÄk+1 ‚â§ [I ‚àí (Œ≥PœÄk+1 )]‚àí1
(T
dV
œÄk ‚àí TœÄk+1 V
œÄk ) from (B.1) on the
last term of the right side of (B.2) along with a power series expansion on the inverse, we
obtain:
V
‚àó ‚àí V
œÄk+1 ‚â§ (Œ≥PœÄ‚àó )
d
(V
‚àó ‚àí V
œÄk ) + 
I + (Œ≥PœÄk+1 )
X‚àû
j=0
(Œ≥PœÄk+1 )
j


T
dV
œÄk ‚àí TœÄk+1 V
œÄk

= (Œ≥PœÄ‚àó )
d
(V
‚àó ‚àí V
œÄk ) +
I ‚àí (Œ≥PœÄk+1 )
‚àí1

T
dV
œÄk ‚àí TœÄk+1 V
œÄk

,
which can be iterated to show:
V
‚àó ‚àíV
œÄK ‚â§ (Œ≥PœÄ‚àó )
Kd (V
‚àó ‚àíV
œÄ0
) +X
K
k=1
(Œ≥PœÄ‚àó )
(K‚àík) d

I ‚àí(Œ≥PœÄk
)
‚àí1

T
dV
œÄk‚àí1 ‚àíTœÄk V
œÄk‚àí1

.
The statement from the lemma follows from taking absolute value, bounding by the maximum norm, and integrating.
B.2 Proof of Lemma 2
For part (a), we note the following:
kTœÄ V ‚àí TœÄ V
¬µ
k1,œÅ1 = Œ≥
Z
S

(PœÄ V )(s) ‚àí (PœÄ V
¬µ
)(s)

 œÅ1(ds)
‚â§ Œ≥
Z
S

V (s) ‚àí V
¬µ
(s)


d(œÅ1PœÄ)
dœÅ0
œÅ0(ds)
‚â§ Œ≥








d(œÅ1PœÄ)
dœÅ0








‚àû
kV ‚àí V
¬µ
k1,œÅ0
.
By the concentrability conditions of Assumption 5, the right-hand-side can be bounded by
Œ≥ A0
1
kV ‚àí V
¬µk1,œÅ0
. Now, we can apply the same steps with the roles of TœÄ V and TœÄ V
¬µ
reversed to see that the same inequality holds for kTœÄ V ‚àíTœÄ V
¬µk1,œÅ1
and part (a) is complete.
2
Feedback-Based Tree Search for Reinforcement Le
For part (b), we partition the state space S into two sets:
S
+ =

s ‚àà S : (T
dJ)(s) ‚â• (T
dV
¬µ
)(s)
	
and S
- =

s ‚àà S : (T
dJ)(s) < (T
dV
¬µ
)(s)
	
.
We start with S
+
. Consider the finite-horizon d-stage MDP with terminal value J and the
same dynamics as our infinite-horizon MDP of interest. Let œÄ
J
1
, œÄJ
2
, . . . , œÄJ
d
be the timedependent optimal policy for this MDP. Thus, we have
TœÄ
J
1
TœÄ
J
2
¬∑ ¬∑ ¬∑ TœÄ
J
d
J = T
dJ and TœÄ
J
1
TœÄ
J
2
¬∑ ¬∑ ¬∑ TœÄ
J
d
V
¬µ ‚â§ T
dV
¬µ
.
Using similar steps as for part (a), the following hold:
Z
S+

(T
dJ)(s) ‚àí (T
dV
¬µ
)(s)

œÅ1(ds) ‚â§
Z
S+

(T
dT
h
¬µ V )(s) ‚àí (TœÄ
J
1
TœÄ
J
2
¬∑ ¬∑ ¬∑ TœÄ
J
d
T
h
¬µ V
¬µ
)(s)

œÅ1(ds)
‚â§ Œ≥
d+h
Z
S+

V (s) ‚àí V
¬µ
(s)


d(œÅ1PœÄ
J
1
PœÄ
J
2
¬∑ ¬∑ ¬∑ PœÄ
J
d
P
h
¬µ
)
dœÅ0
œÅ0(ds)
‚â§ Œ≥
d+h A
0
d+h
Z
S+

V (s) ‚àí V
¬µ
(s)

 œÅ0(ds).
Now, using the optimal policy with respect to the d-stage MDP with terminal condition
V
¬µ
, we can repeat these steps to show that
Z
S-

(T
dV
¬µ
)(s) ‚àí (T
dJ)(s)

œÅ1(ds) ‚â§ Œ≥
d+h A
0
d+h
Z
S-

V (s) ‚àí V
¬µ
(s)

 œÅ0(ds).
Summing the two inequalities, we obtain:
kT
dJ ‚àí T
dV
¬µ
k1,œÅ1 ‚â§ Œ≥
d+h A
0
d+h
Z
S+

V (s) ‚àí V
¬µ
(s)

 œÅ0(ds) + Z
S-

V (s) ‚àí V
¬µ
(s)

 œÅ0(ds)

= Œ≥
d+h A
0
d+h
kV ‚àí V
¬µ
k1,œÅ0
,
which completes the proof.
B.3 Additional Technical Lemmas
Lemma B.1 (Section 4, Corollary 2 of Haussler [1992]). Let G be a set of functions from
X to [0, B] with pseudo-dimension dG < ‚àû. Then for all 0 <  ‚â§ B, it holds that
P

sup
g‚ààG




1
m
Xm
i=1
g(X(i)
) ‚àí E

g(X)





> !
‚â§ 8

32eB

log 32eB

dG
exp 
‚àí

2m
64B2

, (B.3)
where X(i) are i.i.d. draws from the distribution of the random variable X.
Lemma B.2. Consider a policy ¬µ ‚àà Œ† and suppose each s
i
is sampled i.i.d. from œÅ0.
Define initial states s
ij
0 = s
i
for all j. Analogous to Step 5 of the algorithm and Assumption
1, let:
YÀÜ (s
i
) = 1
M0
X
M0
j=1
X‚àû
t=0
Œ≥
t
r(s
ij
t
, ¬µ(s
ij
t
)) and V ‚àà arg min
f‚ààF¬Ø
1
N0
X
N0
i=1

f(s
i
) ‚àí YÀÜ (s
i
)


.
3
Feedback-Based Tree Search for Reinforcement Learning
For Œ¥ ‚àà (0, 1) and  ‚àà (0, Vmax), if the number of sampled states N0 satisfies the condition:
N0 ‚â•

32Vmax

2 
log 32
Œ¥
+ 2dF¬Ø log 64eVmax


=: Œìa(, Œ¥),
and the number of rollouts performed from each state M0 satisfies:
M0 ‚â• 8

Vmax

2
log 8N0
Œ¥
=: Œìb(, Œ¥),
then we have the following bound on the error of the value function approximation:
kV ‚àí V
¬µ
k1,œÅ0 ‚â§ min
f‚ààF¬Ø
kf ‚àí V
¬µ
k1,œÅ0 + ,
with probabilty at least 1 ‚àí Œ¥.
Proof. Recall that the estimated value function V satisfies
V ‚àà arg min
f‚ààFb
1
N0
X
N0
i=1





f(s
i
) ‚àí
1
M0
X
M0
j=1
h
V
œÄ
(s
i
0
) + Œæ
j
(s
i
0
)
i





,
where for each i, the terms Œæ
j
(s
i
0
) are i.i.d. mean zero error. The inner summation over j is
an equivalent way to write YÀÜ (s
i
0
). Noting that the rollout results V
¬µ
(s
i
0
)+Œæ
j
(s
i
0
) ‚àà [0, Vmax],
we have by Hoeffding‚Äôs inequality followed by a union bound:
P

max
i

YÀÜ (s
i
0
) ‚àí V
¬µ
(s
i
0
)

 > 
‚â§ N0 ‚àÜ1(, M0), (B.4)
where ‚àÜ1(, M0) = 2 exp
‚àí2M0 
2/V 2
max
. Define the function
‚àÜ2(, N0) = 8 
32eVmax

log 32eVmax

dF¬Ø
exp 
‚àí

2N0
64V 2
max 
,
representing the right-hand-side of the bound in Lemma B.1 with B = Vmax and m = N0.
Next, we define the loss minimizing function f
‚àó ‚àà arg minf‚ààF¬Ø kf ‚àíV
¬µk1,œÅ0
. By Lemma B.1,
the probabilities of the events




kV ‚àí V
¬µ
k1,œÅ0 ‚àí
1
N0
X
N0
i=1

V (s
i
) ‚àí V
¬µ
(s
i
)






>

4

and




kf
‚àó ‚àí V
¬µ
k1,œÅ0 ‚àí
1
N0
X
N0
i=1

f
‚àó
(s
i
) ‚àí V
¬µ
(s
i
)






>

4

(B.5)
are each bounded by ‚àÜ2(/4, N0). Also, it follows by the definition of V that
1
N0
X
N0
i=1

V (s
i
) ‚àí YÀÜ (s
i
)

 ‚â§
1
N0
X
N0
i=1

f
‚àó
(s
i
) ‚àí YÀÜ (s
i
)


.
Therefore, using (B.4) twice and (B.5) once, we have by a union bound that the inequality
kV ‚àí V
¬µ
k1,œÅ0 ‚â§ minf‚ààF¬Ø kf ‚àí V
¬µk1,œÅ0 + 
4
Feedback-Based Tree Search for Reinforcement Learnin
happens with probability greater than 1 ‚àí 2 N0 ‚àÜ1(/4, M0) ‚àí 2 ‚àÜ2(/4, N0). We then
choose N0 so that ‚àÜ2(/4, N0) = Œ¥/4 (following Haussler [1992], we utilize the inequality log(a log a) < 2 log(a/2) for a ‚â• 5). To conclude, we choose M0 so that ‚àÜ1(/4, M0) =
Œ¥/(4N0).
Lemma B.3 (Sampling Error). Suppose |A| = 2 and let dŒ†¬Ø be the VC-dimension of Œ†¬Ø .
Consider Z, V ‚àà F and suppose each s
i
is sampled i.i.d. from œÅ1. Also, let w
j
be i.i.d.
samples from the standard uniform distribution and g : S √ó A √ó [0, 1] ‚Üí S be a transition
function such that g(s, a, w) has the same distribution as p(¬∑|s, a). For Œ¥ ‚àà (0, 1) and
 ‚àà (0, Vmax), if the number of sampled states N1 satisfies the condition:
N1 ‚â• 128 
Vmax

2 
log 8
Œ¥
+ dŒ†¬Ø log eN1
dŒ†¬Ø

=: Œìc(, Œ¥, N1),
and the number of sampled transitions L1 satisfies:
L1 ‚â• 128 
Vmax

2 
log 8
Œ¥
+ dŒ†¬Ø log eL1
dŒ†¬Ø

=: Œìd(, Œ¥, L1),
then we have the bounds:
(a) sup
œÄ‚ààŒ†¬Ø




1
N1
X
N1
i=1
|Z(s
i
) ‚àí (TœÄ V )(s
i
)| ‚àí kZ ‚àí TœÄ V k1,œÅ1




‚â§  w.p. at least 1 ‚àí Œ¥.
(b) sup
œÄ‚ààŒ†¬Ø




1
L1
X
L1
j=1
h
r(s
i
, œÄ(s
i
)) +Œ≥ V
g(s
i
, œÄ(s
i
), wj
)

i
‚àí(TœÄ V )(s
i
)




‚â§  w.p. at least 1‚àíŒ¥.
Proof. We remark that in both (a) and (b), the term within the absolute value is bounded
between 0 and Vmax. A second remark is that we reformulated the problem using w
j
to
take advantage of the fact that these random samples do not depend on the policy œÄ. Such
a property is required to invoke [Gy¬®orfi et al., 2006, Theorem 9.1], a result that [Lazaric
et al., 2016, Lemma 3] depends on. With these two issues in mind, an argument similar to
the proof of [Lazaric et al., 2016, Lemma 3] gives the conclusion for both (a) and (b).
B.4 Proof of Lemma 3
On each iteration of the the algorithm, two random samples are used: S0,k and S1,k. From
S0,k, we obtain Vk and from S1,k we obtain œÄk+1. Let Sk = (S0,k, S1,k) represent both of
the samples at iteration k. We define:
Gk‚àí1 = œÉ{S1, S2, . . . , Sk‚àí1} and G
0
k‚àí1 = œÉ{S1, S2, . . . , Sk‚àí1, S0,k}.
Due to the progression of the algorithm with two random samples per iteration, we will
analyze each iteration in two steps. We first separate the two random samples by noting
5
Feedback-Based Tree Search for Reinforcement Learnin
that:
kT
dV
œÄk ‚àí TœÄk+1 V
œÄk k1,œÅ1 ‚â§ kT
dV
œÄk ‚àí T
dJkk1,œÅ1 + kTœÄk+1 Vk ‚àí TœÄk+1 V
œÄk k1,œÅ1
+ kT
dJk ‚àí TœÄk+1 Vkk1,œÅ1
‚â§ (Œ≥ A0
1 + Œ≥
d+hA
0
d+h
) kVk ‚àí V
œÄk k1,œÅ0 + kT
dJk ‚àí TœÄk+1 Vkk1,œÅ1
,
(B.6)
where the first inequality follows by adding and subtracting terms and the triangle inequality
while the second inequality follows by Lemma 2. Now, we may analyze the first term on
the right-hand-side conditional on Gk‚àí1 and the second term conditional on G
0
k‚àí1
.
As it is currently stated, Lemma B.2 gives an unconditional probability for a fixed
policy ¬µ. However, since S0,k is independent from Gk‚àí1 and œÄk is Gk‚àí1-measurable, we
can utilize Lemma B.2 in a conditional setting using a well-known property of conditional
expectations [Resnick, 2013, Property 12, Section 10.3]. This property will be repeatedly
used in this proof (without further mention). We obtain that for a sample size N0 ‚â•
Œìa(
0/(Œ≥ A0
1 + Œ≥
d+hA0
d+h
), Œ¥0
),
P

kVk ‚àí V
œÄk k1,œÅ0 > min
f‚ààF¬Ø
kf ‚àí V
œÄk k1,œÅ0 + 
0
/(Œ≥ A0
1 + Œ≥
d+hA
0
d+h
)

 Gk‚àí1

‚â§ Œ¥
0
. (B.7)
It remains for us to analyze the error of the second term kT
dJk ‚àí TœÄk+1 Vkk1,œÅ1
. By part (a)
of Lemma B.3 with Z = T
dJk and V = Vk, if N1 ‚â• Œìc(
0
, Œ¥0
, N1) and s
i are sampled i.i.d.
from œÅ1, we have
P
 



1
N1
X
N1
i=1

(T
dJk)(s
i
) ‚àí (TœÄk+1 Vk)(s
i
)

 ‚àí



T
dJk ‚àí TœÄk+1 Vk




1,œÅ1




> 0


 G
0
k‚àí1
!
‚â§ Œ¥
0
. (B.8)
The term (TœÄk+1 Vk)(s
i
) is approximated using L1 samples. Part (b) of Lemma B.3 along
with a union bound shows that if L1 ‚â• Œìd(
0
, Œ¥0/N1, L1), then
P

max
i

QÀÜ
k(s
i
, œÄk+1(s
i
)) ‚àí (TœÄk+1 Vk)(s
i
)

 > 0

 G
0
k‚àí1

‚â§ Œ¥
0
. (B.9)
Similarly, by Assumption 3, if the number of iterations of MCTS M1 exceeds m(
0
, Œ¥0/N1),
we can take a union bound to arrive at
P

max
i

UÀÜ
k(s
i
) ‚àí (T
dJk)(s
i
)

 > 0


 G
0
k‚àí1

‚â§ Œ¥
0
. (B.10)
The maximum over i can be replaced with an average over the N1 samples and the conclusion
of the last two bounds would remain unchanged. Since œÄk+1 is assumed to optimize a
quantity involving UÀÜ
k and QÀÜ
k, we want to relate this back to kT
dJk ‚àíTœÄk+1 Vkk1,œÅ1
. Indeed,
taking expectation of both sides of inequalities (B.8)‚Äì(B.10) and then combining, we obtain
that with probability at least 1 ‚àí 3Œ¥
0
,



T
dJk ‚àí TœÄk+1 Vk




1,œÅ1
‚â§
1
N1
X
N1
i=1

UÀÜ
k(s
i
) ‚àí QÀÜ
k(s
i
, œÄk+1(s
i
))

 + 3
0
6
Feedback-Based Tree Search for Reinforcement Learning
‚â§
1
N1
X
N1
i=1

UÀÜ
k(s
i
) ‚àí QÀÜ
k(s
i
, œÄÀú(s
i
))

 + 3
0
where ÀúœÄ ‚àà arg minœÄ‚ààŒ†¬Ø kT
dV
œÄk ‚àíTœÄ V
œÄk k1,œÅ1
. Following the same steps in reverse , we have:



T
dJk ‚àí TœÄk+1 Vk




1,œÅ1
‚â§ min
œÄ‚ààŒ†¬Ø
kT
dV
œÄk ‚àí TœÄ V
œÄk k1,œÅ1 + 6
0
, (B.11)
with probability at least 1 ‚àí 6 Œ¥
0
. Finally, we take expectation of both sides of (B.7) and
then combine with (B.6) and (B.11) while setting 
0 = /7 and Œ¥
0 = Œ¥/7 to obtain
kT
dV
œÄk ‚àí TœÄk+1 V
œÄk k1,œÅ1 ‚â§ (Œ≥ A0
1 + Œ≥
d+hA
0
d+h
) min
f‚ààF¬Ø
kf ‚àí V
œÄk k1,œÅ0
+ min
œÄ‚ààŒ†¬Ø
kT
dV
œÄk ‚àí TœÄ V
œÄk k1,œÅ1 + 
with probability at least 1 ‚àí Œ¥.
B.5 Proof of Theorem 1
This proof synthesizes the previous lemmas. From the definition of D0(Œ†¬Ø , F¬Ø) and D
d
1
(Œ†) ¬Ø
from the main paper, we note that if the sample size assumptions of Lemma 3 are satisfied,
kT
dV
œÄk‚àí TœÄk+1 V
œÄk k1,œÅ1 ‚â§ B
0
Œ≥ D0(Œ†¬Ø, F¬Ø) + D
d
1
(Œ†) + ¬Ø , (B.12)
with probability at least 1 ‚àí Œ¥. This removes any dependence on the iteration k from the
right-hand-side. We now integrate all results with Lemma 1 in order to find a bound on
the suboptimality kV
‚àó ‚àí V
œÄK k1,ŒΩ. Consider the distribution ŒõŒΩ,k, as defined in Lemma 1,
which needs to be related to ŒΩ. We can use the power series expansion to write:
ŒõŒΩ,k = ŒΩ (PœÄ‚àó )
K‚àík X‚àû
i=0
(Œ≥PœÄk
)
i
.
For a fixed i, the measure ŒΩ is transformed by applying œÄ
‚àó a total of K ‚àí k times and then
œÄk a total of i times. We see that the summation term on the right-hand-side of Lemma 1
can be upper-bounded in the following way:
X
K
k=1
Œ≥
K‚àík



T
dV
œÄk‚àí1 ‚àí TœÄk V
œÄk‚àí1




1,ŒõŒΩ,k
‚â§
K
X‚àí1
j=0
X‚àû
i=0
Œ≥
j+i Aj+i

max
k‚â§K



T
dV
œÄk‚àí1 ‚àí TœÄk V
œÄk‚àí1




1,œÅ1
,
where we use Assumption 5 with m = K ‚àí k + i, maximize over k for the loss term, and
then re-index with j = K ‚àí k. The coefficient in parentheses can be upper-bounded by BŒ≥
(since all Aj+i are nonnegative). Finally, we use (B.12) and then a union bound over the
K iterations to conclude the statement of the theorem.
7
Feedback-Based Tree Search for Reinforcement Learning
C Implementation Details
C.1 Neural Network Architecture
The policy and value function approximations use fully-connected neural networks with five
and two hidden layers, respectively, and SELU (scaled exponential linear unit) activation
[Klambauer et al., 2017]. The policy network contains two sets of outputs: (1) one of seven
actions (no action, normal attack, move, skill 1, skill 2, skill 3, and heal) and (2) a twodimensional direction parameter used for the action. The first two hidden layers are shared
and have 120 and 100 hidden units, while each of the two outputs corresponds to a set of
three hidden layers with 80, 70, and 50 hidden units. The value function approximation
uses a fully-connected network with 128 hidden units in the first layer and 96 hidden units
in the second layer. As mentioned in the main paper, this architecture is consistent across
all agents whenever policy and/or value networks are needed.
C.2 Features of the State
As shown in Table 1, the state of the game is represented by 41-dimensional feature vector,
which was constructed using the output from the game engine and API. The features consists
of basic attributes of the two heroes, the computer-controlled units, and structures. The
feature lists also have information on the relative positions of the other units and structures
with respect to the hero controlled by algorithm.
Table 1: State Feature List
No. Feature Dimensions
1 Location of Hero 1 2
2 Location of Hero 2 2
3 HP of Hero 1 1
4 HP of Hero 2 1
5 Hero 1 skill cooldowns 5
6 Hero 2 skill cooldowns 5
7 Direction to enemy hero 3
8 Direction to enemy tower 4
9 Direction to enemy minion 3
10 Enemy tower HP 1
11 Enemy minion HP 1
12 Direction to the spring 3
13 Total HP of allied minions 1
14 Enemy‚Äôs tower attacking Hero 1 3
15 Hero 1 in range of enemy towers 3
16 Hero 2 in range of enemy towers 3
8
Feedback-Based Tree Search for Reinforcement Learning
C.3 Tree Search Details
We provide some more information regarding the implementation of feedback-based tree
search. A major challenge in implementing in King of Glory is that the game engine can
only move forward, meaning that our sampled states are not i.i.d. and instead follow the
trajectory of the policy induced by MCTS. However, to decrease the correlation between
visited states, we inject random movements and random switches to the internal AI policy
in order to move to a ‚Äúmore random‚Äù next state. Rollouts are performed on separate
processors to enable tree search in a game engine that cannot rewind. All experiments use
the c4.2xlarge instances on Amazon Web Services, and we utilized parallelization across
four cores within each call to MCTS.
References
L. Gy¬®orfi, M. Kohler, A. Krzyzak, and H. Walk. A Distribution-free Theory of Nonparametric Regression. Springer Science & Business Media, 2006.
D. Haussler. Decision theoretic generalizations of the PAC model for neural net and other
learning applications. Information and Computation, 100(1):78‚Äì150, 1992.
G. Klambauer, T. Unterthiner, A. Mayr, and S. Hochreiter. Self-normalizing neural networks. In Advances in Neural Information Processing Systems, pages 972‚Äì981, 2017.
A. Lazaric, M. Ghavamzadeh, and R. Munos. Analysis of classification-based policy iteration
algorithms. Journal of Machine Learning Research, 17(19):1‚Äì30, 2016.
S. I. Resnick. A Probability Path. Springer Science & Business Media, 2013.
9
Feedback-Based Tree Search for Reinforcement Learning